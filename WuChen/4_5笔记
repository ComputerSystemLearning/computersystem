1.这次学长讲解了一下他的模拟内核调度的程序，结构体中包括进程号，进程所处的状态值(运行 ，阻塞，就绪)，双向链表的前后指针。
学长动态申请了就绪和阻塞的等待队列，并一开始默认所有的进程刚开始都处于就绪，用对5取余的方式去解决它的优先级问题，
对于他是如何将进程在运行，阻塞，就绪间调整的我自己不是很理解，不过第一次看到内核对进程的调度原来是这个样子，也可以用队列，链表简单的去实现，
对于一个从来没看过内核代码的，不明白内核是怎么调度进程的，感觉内核应该是一个很庞大，无法具体实现的程序的人来说有了一种豁然开朗的感觉。
学长的程序是顺序执行的，并没有采用多线程的方式。
可以创建线程，让线程去从队列中移除线程，每个线程由主线程控制作业的分配，主线程在每个待处理作业的结构中放置处理该作业的线程ID,
每个工作线程只能移出标有自己线程ID的作业(书上的解释，我并不是很明白线程和cpu之间的关系，好像cpu是一次只能给一个进程使用，对于线程好像可以多线程使用，
不是很清楚了)               
2.对于多线程来说，为了避免多个线程在读取同一块内存区时数据不会出现差异，因此要是用锁 。                                                            
3.在学长讲解代码后，看到学长的代码规范很是问题，比如，函数的命名规则，要表达出这个函数的意思来让人一目了然，等号的左右要有空格，
孔学长让我们看来内核中c的代码和对比了一下c++的驱动代码。